> ✏️ 关于专栏：专栏用于记录蓝桥杯做题与总结 
> 😭😭

[TOC]

### 1.奇怪的捐赠

地产大亨 Q 先生临终的遗愿是：拿出 100万元给 X 社区的居民抽奖，以稍慰藉心中愧疚。

麻烦的是，他有个很奇怪的要求：

1. 100万元必须被正好分成若干份（不能剩余）。每份必须是7的若干次方元。比如：1元, 7元， 49元，343元，...
2. 相同金额的份数不能超过 5 份。
3. 在满足上述要求的情况下，分成的份数越多越好！

请你帮忙计算一下，最多可以分为多少份？

#### 思路

这道题目涉及将 100 万元分配成若干份，每份金额为 7 的某次方元，并且要满足以下条件：

1. 每份金额必须是 7 的幂次（例如 1 元, 7 元, 49 元, 343 元...）。
2. 相同金额的份数不能超过 5 份。
3. 在满足上述条件的前提下，我们需要分得尽可能多的份数。

首先，题目可以转化为数学上的进制问题。由于每份金额必须是 7 的某次方元，我们可以将 100 万转换为 7 进制，然后查看各位上的数字和，以求得最大份数。为什么要这样做呢？因为在 7 进制中，每一位上的数字代表的是 7 的幂次的系数，这正好符合题目的要求。

1. **转换为 7 进制**：通过将 100 万除以 7 并取余，直到商为 0，得到 7 进制的表示。
2. **求和**：由于每个 7 的幂次最多使用 5 次，因此计算 7 进制表示中每一位的数字总和，就是分配份数的最大值。

通过这种方法，我们能找到满足条件的最大分配份数。

<img src="https://gitee.com/Black_aura/picture/raw/master/img/image-20241114194804407.png" alt="image-20241114194804407" style="zoom: 50%;" />

#### 代码

```c++
#include<iostream>
#include<vector>
using namespace std;
int main(){
    vector<int>ans = {0};
    int count = 0;
    int sor = 0;
   	int n = 1000000;
    while(n){
        ans[sor++] = n % 7;
        n /= 7;
    }
    for(int it = sor - 1;it >= 0;it--){
        count += ans[it];
    }
    cout<<count<<endl;
    return 0;
}
```

#### 代码解析

1. **7 进制转换**：首先通过 `n % 7` 获取 100 万在 7 进制下每一位的值，然后将 `n /= 7` 进行逐步除法操作，直到 `n` 为 0。
2. **统计和**：我们遍历从高位到低位的每一位，将这些位上的数字加总。最终这个总和即为最大分配份数。

#### 知识补充

##### 十进制转k进制

方法：十进制数除以k，余数为权位上的数，得到商继续除以 ，直到商为0停止，然后反向取余数

<img src="https://gitee.com/Black_aura/picture/raw/master/img/image-20241114200833805.png" alt="image-20241114200833805" style="zoom: 25%;" />

```c++
#include <bits/stdc++.h> // 包含标准头文件
using namespace std;
long long s, base; // 定义两个长整型变量，s 为要转换的数，base 为进制
string p = "0123456789ABCDEF"; // 定义字符串 p，存储 16 进制数的所有可能字符
string ans; // 定义字符串 ans，用于存储转换后的结果
int main() {
	cin >> s >> base; // 输入要转换的数 s 和进制 base
	while (s) { // 当 s 不为 0 时循环
		ans.push_back(p[s % base]); // 将 s 对 base 取模的结果作为索引，将对应的字符添加到 ans 末尾
		s /= base; // 将 s 除以 base，更新 s 的值
	}
	reverse(ans.begin(), ans.end()); // 将 ans 反转，因为从末尾开始计算的结果需要反转才能得到正确的结果
	cout << ans; // 输出转换后的结果
	return 0; // 返回0，表示程序正常结束
}
```

##### k进制转十进制

方法：k进制转10进制是另一个常见的数制转换问题，其基本思想是将k进制数按权展开，然后将每一位的值乘以其对应的权重（k的幂次）并求和。

```c++
#include<bits/stdc++.h>
using namespace std;
int main() {
	string s;
	long long base = 0, ans = 0, k = 0; // 初始化所有变量
	// 输入字符串s和进制base
	cin >> s >> base;
	// 从字符串末尾开始遍历
	for(int i = s.size() - 1; i >= 0; i--) {
		// 如果字符为大写字母
		if(s[i] >= 'A') {
		ans += (s[i] - 'A' + 10) * pow(base, k++); // 更新结果
	} else {
		ans += (s[i] - '0') * pow(base, k++); // 更新结果
	 }
   }
   // 输出结果
	cout << ans;
 	return 0;
}
```

#### 总结

通过将问题转化为进制计算问题，我们可以轻松解决该题。关键在于将目标金额（100 万）转换为 7 进制，利用其位上数字的和来计算最大分配份数。进制转换和计算是这道题的核心技巧，掌握了这些方法后，类似的题目也能更快地解决。

扩展资料参考：https://dashoj.com/p